const { getEmbedding } = require('./modelAI'); 
const mongoose = require('mongoose');

// ‚úÖ 1. ƒê·ªãnh nghƒ©a schema MongoDB
const chatSchema = new mongoose.Schema({
    userId: { type: String, required: true, index: true },
    role: { type: String, required: true, enum: ['system', 'user', 'assistant'] },
    content: { type: String, required: true },
    timestamp: { type: Date, default: Date.now, index: true }
});

const activeUserSchema = new mongoose.Schema({
    userId: { type: String, required: true, unique: true },
    displayName: { type: String, required: true },
    channelID: { type: String, required: true },
    timestamp: { type: Date, default: Date.now }
});

const vectorSchema = new mongoose.Schema({
    userId: { type: String, required: true, index: true },
    content: { type: String, required: true },
    embedding: { type: [Number], required: true }, // ‚úÖ ƒê·ªãnh d·∫°ng vector
    timestamp: { type: Date, default: Date.now }
});

const VectorModel = mongoose.model('Vector', vectorSchema);
const Chat = mongoose.model('Chat', chatSchema);
const ActiveUser = mongoose.model('ActiveUser', activeUserSchema);

// ‚úÖ 2. K·∫øt n·ªëi MongoDB
async function connectDB() {
    try {
        await mongoose.connect(process.env.MONGODB_URI, {
            serverSelectionTimeoutMS: 5000
        });
        console.log("‚úÖ ƒê√£ k·∫øt n·ªëi MongoDB!");
    } catch (error) {
        console.error("‚ùå L·ªói k·∫øt n·ªëi MongoDB:", error.message);
        process.exit(1);
    }
}

// ‚úÖ 3. Qu·∫£n l√Ω danh s√°ch user ƒëang chat
async function addActiveUser(userId, displayName, channelId) {
    if (!channelId) {
        console.error(`‚ùå L·ªói: channelId kh√¥ng t·ªìn t·∫°i khi th√™m user ${userId}`);
        return;
    }
    try {
        console.log(`üìå DEBUG: L∆∞u user ${userId} v√†o activeUsers v·ªõi channelId ${channelId}`);
        await ActiveUser.findOneAndUpdate(
            { userId },
            { displayName, channelID: channelId, timestamp: new Date() },
            { upsert: true, new: true }
        );
        console.log(`‚úÖ addActiveUser: ƒê√£ l∆∞u th√†nh c√¥ng user ${userId}`);
    } catch (error) {
        console.error("üì¶ L·ªói khi th√™m user v√†o danh s√°ch chat:", error.message);
    }
}

async function removeActiveUser(userId) {
    try {
        await ActiveUser.deleteOne({ userId });
    } catch (error) {
        console.error("üì¶ L·ªói x√≥a user kh·ªèi danh s√°ch chat:", error.message);
    }
}

async function isActiveUser(userId) {
    return !!(await ActiveUser.findOne({ userId }));
}

async function getActiveUsers() {
    try {
        return await ActiveUser.find().lean();
    } catch (error) {
        console.error("üì¶ L·ªói l·∫•y danh s√°ch user ƒëang chat:", error.message);
        return [];
    }
}

// ‚úÖ 4. L∆∞u l·ªãch s·ª≠ chat & vector embeddings
async function saveChatHistory(userId, role, content) {
    try {
        const embedding = await getEmbedding(content);
        
        if (!embedding || !Array.isArray(embedding) || embedding.length === 0) {
            console.error("‚ö†Ô∏è Kh√¥ng th·ªÉ t·∫°o embedding, b·ªè qua l∆∞u vector.");
            return;
        }

        await Promise.all([
            Chat.create({ userId, role, content }),
            VectorModel.create({ userId, content, embedding: embedding[0] }) // ‚úÖ L∆∞u ƒë√∫ng vector ƒë·∫ßu ti√™n
        ]);

        console.log(`‚úÖ ƒê√£ l∆∞u chat + vector v√†o database cho user ${userId}`);
    } catch (error) {
        console.error("üì¶ L·ªói l∆∞u d·ªØ li·ªáu:", error.message);
    }
}

// ‚úÖ 5. L·∫•y l·ªãch s·ª≠ chat
async function getChatHistory(userId) {
    try {
        const chatHistory = await Chat.find({ userId })
            .sort({ timestamp: 1 }) // S·∫Øp x·∫øp t·ª´ c≈© -> m·ªõi ƒë·ªÉ gi·ªØ ng·ªØ c·∫£nh
            .lean();

        if (!chatHistory || chatHistory.length === 0) {
            console.warn(`‚ö†Ô∏è Kh√¥ng c√≥ l·ªãch s·ª≠ chat n√†o cho user ${userId}`);
            return { messages: [], fullText: "" };
        }

        // G·ªôp n·ªôi dung tin nh·∫Øn th√†nh m·ªôt ƒëo·∫°n vƒÉn b·∫£n
        const fullText = chatHistory.map(chat => chat.content).join("\n");

        return { messages: chatHistory, fullText };

    } catch (error) {
        console.error("‚ùå L·ªói l·∫•y l·ªãch s·ª≠ chat:", error.message);
        return { messages: [], fullText: "" };
    }
}


// ‚úÖ 6. T√¨m ki·∫øm user theo channel
async function getUserChannel(userId) {
    const user = await ActiveUser.findOne({ userId });
    console.log(`[DEBUG] User ${userId} c√≥ channelID trong DB: ${user?.channelID}`);
    return user ? user.channelID : null;
}

// ‚úÖ 7. T√¨m ki·∫øm vector b·∫±ng cosine similarity
function cosineSimilarity(vecA, vecB) {
    const dotProduct = vecA.reduce((sum, a, i) => sum + a * vecB[i], 0);
    const normA = Math.sqrt(vecA.reduce((sum, a) => sum + a * a, 0));
    const normB = Math.sqrt(vecB.reduce((sum, b) => sum + b * b, 0));
    return dotProduct / (normA * normB);
}

async function vectorSearch(userId, query, k = 5) {
    try {
        console.log(`üìå [DEBUG] B·∫Øt ƒë·∫ßu t√¨m ki·∫øm vector cho user ${userId}`);
        
        const queryEmbedding = await getEmbedding(query);
        if (!queryEmbedding || !Array.isArray(queryEmbedding) || queryEmbedding.length === 0){
            console.warn("‚ö†Ô∏è Kh√¥ng th·ªÉ t·∫°o embedding, b·ªè qua t√¨m ki·∫øm vector.");
            return [];
        }

        const userVectors = await VectorModel.find({ userId }).lean();
        console.log(`üìå [DEBUG] S·ªë l∆∞·ª£ng vectors trong DB: ${userVectors.length}`);
        
        if (userVectors.length === 0) {
            console.warn("‚ö†Ô∏è Kh√¥ng c√≥ vector n√†o trong database.");
            return [];
        }

        const results = userVectors.map(doc => {
            if (queryEmbedding[0].length !== doc.embedding.length) {
                console.error(`‚ùå K√≠ch th∆∞·ªõc vector kh√¥ng kh·ªõp! Query: ${queryEmbedding[0].length}, DB: ${doc.embedding.length}`);
                return null;
            }
            return { 
                content: doc.content, 
                similarity: cosineSimilarity(queryEmbedding[0], doc.embedding) 
            };
        }).filter(res => res !== null); // L·ªçc ra c√°c ph·∫ßn t·ª≠ h·ª£p l·ªá

        return results
            .sort((a, b) => b.similarity - a.similarity)
            .slice(0, k)
            .map(res => res.content);
      
    } catch (error) {
        console.error("‚ùå L·ªói t√¨m ki·∫øm vector:", error.message);
        return [];
    }
}

// ‚úÖ 8. Ph√¢n t√≠ch l·ªãch s·ª≠ chat
function detectPreferences(topics) {
    if (!topics || topics.length === 0) return "Kh√¥ng c√≥ s·ªü th√≠ch c·ª• th·ªÉ.";
    return `Ng∆∞·ªùi d√πng c√≥ xu h∆∞·ªõng quan t√¢m ƒë·∫øn: ${topics.join(", ")}.`;
}

function analyzeTopics(text) {
    const topics = [];

    if (text.includes('game')) topics.push('Game');
    if (text.includes('nh·∫°c')) topics.push('√Çm nh·∫°c');
    if (text.includes('AI')) topics.push('Tr√≠ tu·ªá nh√¢n t·∫°o');
    if (text.includes('code')) topics.push('L·∫≠p tr√¨nh');
    if (text.includes('chatbot')) topics.push('Chatbot');
    if (text.includes('c√¥ng th·ª©c')) topics.push('C√¥ng th·ª©c To√°n h·ªçc');

    return [...new Set(topics)];
}

async function getUserProfile(userId) {
    try {
        const { fullText } = await getChatHistory(userId);

        if (!fullText || typeof fullText !== "string") {
            console.warn(`‚ö†Ô∏è L·ªãch s·ª≠ chat c·ªßa user ${userId} tr·ªëng ho·∫∑c kh√¥ng h·ª£p l·ªá.`);
            return { commonTopics: [], preferences: "Kh√¥ng c√≥ l·ªãch s·ª≠ chat." };
        }

        const topics = analyzeTopics(fullText);
        return {
            commonTopics: topics,
            preferences: detectPreferences(topics)
        };

    } catch (error) {
        console.error("‚ùå L·ªói ph√¢n t√≠ch l·ªãch s·ª≠:", error.message);
        return { commonTopics: [], preferences: "L·ªói h·ªá th·ªëng, kh√¥ng th·ªÉ ph√¢n t√≠ch." };
    }
}


// ‚úÖ 9. Xu·∫•t c√°c h√†m
module.exports = { 
    connectDB, 
    saveChatHistory, 
    getChatHistory, 
    addActiveUser, 
    removeActiveUser, 
    isActiveUser, 
    getActiveUsers, 
    getUserChannel,
    getUserProfile,
    vectorSearch
};
